import * as assert from 'assert'
import * as t from '../src'

describe('printRuntime', () => {
  it('literalCombinator', () => {
    const declaration = t.typeDeclaration('Foo', t.literalCombinator(1))
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.literal(1)`)
  })

  it('keyofCombinator', () => {
    const declaration = t.typeDeclaration('Foo', t.keyofCombinator(['a', 'b']))
    assert.strictEqual(
      t.printRuntime(declaration),
      `const Foo = t.keyof({
  a: null,
  b: null
})`
    )
  })

  it('keyofCombinator with special characters', () => {
    const declaration = t.typeDeclaration('Foo', t.keyofCombinator(['<', '>']))
    assert.strictEqual(
      t.printRuntime(declaration),
      `const Foo = t.keyof({
  '<': null,
  '>': null
})`
    )
  })

  it('keyofCombinator stating with digit', () => {
    const declaration = t.typeDeclaration('Foo', t.keyofCombinator(['01test', '1']))
    assert.strictEqual(
      t.printRuntime(declaration),
      `const Foo = t.keyof({
  '01test': null,
  '1': null
})`
    )
  })

  it('tupleCombinator', () => {
    const declaration = t.typeDeclaration('Foo', t.tupleCombinator([t.stringType, t.numberType]))
    assert.strictEqual(
      t.printRuntime(declaration),
      `const Foo = t.tuple([
  t.string,
  t.number
])`
    )
  })

  describe('taggedUnionCombinator', () => {
    it('should handle tag and types', () => {
      const declaration = t.typeDeclaration(
        'Foo',
        t.taggedUnionCombinator('type', [
          t.typeCombinator([t.property('type', t.literalCombinator('A'))]),
          t.typeCombinator([t.property('type', t.literalCombinator('B'))])
        ])
      )
      assert.strictEqual(
        t.printRuntime(declaration),
        `const Foo = t.taggedUnion('type', [
  t.type({
    type: t.literal('A')
  }),
  t.type({
    type: t.literal('B')
  })
])`
      )
    })

    it('should handle name', () => {
      const declaration = t.typeDeclaration('Foo', t.taggedUnionCombinator('type', [], 'Foo'))
      assert.strictEqual(
        t.printRuntime(declaration),
        `const Foo = t.taggedUnion('type', [

], 'Foo')`
      )
    })
  })

  describe('typeCombinator', () => {
    it('should handle field descriptions', () => {
      const declaration = t.typeDeclaration(
        'Foo',
        t.typeCombinator([t.property('a', t.stringType, false, 'description')])
      )
      assert.strictEqual(
        t.printRuntime(declaration),
        `const Foo = t.type({
  /** description */
  a: t.string
})`
      )
    })

    it('should escape properties', () => {
      const declaration = t.typeDeclaration(
        'Foo',
        t.typeCombinator([
          t.property('foo bar', t.stringType),
          t.property('image/jpeg', t.stringType),
          t.property('autoexec.bat', t.stringType)
        ])
      )
      assert.strictEqual(
        t.printRuntime(declaration),
        `const Foo = t.type({
  'foo bar': t.string,
  'image/jpeg': t.string,
  'autoexec.bat': t.string
})`
      )
    })

    it('should handle nested types', () => {
      const declaration = t.typeDeclaration(
        'Foo',
        t.typeCombinator([
          t.property('foo', t.stringType),
          t.property('bar', t.typeCombinator([t.property('baz', t.numberType)]))
        ])
      )
      assert.strictEqual(
        t.printRuntime(declaration),
        `const Foo = t.type({
  foo: t.string,
  bar: t.type({
    baz: t.number
  })
})`
      )
    })

    it('should handle the name argument', () => {
      const allRequired = t.typeDeclaration('Foo', t.typeCombinator([t.property('foo', t.stringType)], 'Foo'))
      assert.strictEqual(
        t.printRuntime(allRequired),
        `const Foo = t.type({
  foo: t.string
}, 'Foo')`
      )
      const someOptionals = t.typeDeclaration(
        'Foo',
        t.typeCombinator([t.property('foo', t.stringType), t.property('bar', t.numberType, true)], 'Foo')
      )
      assert.strictEqual(
        t.printRuntime(someOptionals),
        `const Foo = t.intersection([
  t.type({
    foo: t.string
  }),
  t.partial({
    bar: t.number
  })
], 'Foo')`
      )
      const allOptionals = t.typeDeclaration('Foo', t.typeCombinator([t.property('foo', t.stringType, true)], 'Foo'))
      assert.strictEqual(
        t.printRuntime(allOptionals),
        `const Foo = t.partial({
  foo: t.string
}, 'Foo')`
      )
    })

    it('should use type when all properties are required', () => {
      const declaration = t.typeDeclaration(
        'Foo',
        t.typeCombinator([t.property('foo', t.stringType), t.property('bar', t.numberType)])
      )
      assert.strictEqual(
        t.printRuntime(declaration),
        `const Foo = t.type({
  foo: t.string,
  bar: t.number
})`
      )
    })

    it('should use an intersection when there is al least an optional property and a required property', () => {
      const declaration = t.typeDeclaration(
        'Foo',
        t.typeCombinator([t.property('a', t.stringType, true), t.property('b', t.stringType)])
      )
      assert.strictEqual(
        t.printRuntime(declaration),
        `const Foo = t.intersection([
  t.type({
    b: t.string
  }),
  t.partial({
    a: t.string
  })
])`
      )
    })

    it('should use partial when all properties are optional', () => {
      const declaration = t.typeDeclaration('Foo', t.typeCombinator([t.property('a', t.stringType, true)]))
      assert.strictEqual(
        t.printRuntime(declaration),
        `const Foo = t.partial({
  a: t.string
})`
      )
    })

    it('should not add useless `undefinedType`s', () => {
      const declaration = t.typeDeclaration(
        'Foo',
        t.typeCombinator([
          t.property('foo', t.stringType),
          t.property('bar', t.unionCombinator([t.numberType, t.undefinedType]), true)
        ])
      )
      assert.strictEqual(
        t.printRuntime(declaration),
        `const Foo = t.intersection([
  t.type({
    foo: t.string
  }),
  t.partial({
    bar: t.union([
      t.number,
      t.undefined
    ])
  })
])`
      )
    })
  })

  it('partialCombinator', () => {
    const declaration = t.typeDeclaration(
      'Foo',
      t.partialCombinator([t.property('foo', t.stringType), t.property('bar', t.numberType, true)])
    )
    assert.strictEqual(
      t.printRuntime(declaration),
      `const Foo = t.partial({
  foo: t.string,
  bar: t.number
})`
    )
  })

  it('recordCombinator', () => {
    const declaration = t.typeDeclaration('Foo', t.recordCombinator(t.stringType, t.numberType))
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.record(t.string, t.number)`)
  })

  describe('typeDeclaration', () => {
    it('should handle the isExported argument', () => {
      const declaration = t.typeDeclaration('Foo', t.typeCombinator([t.property('foo', t.stringType)], 'Foo'), true)
      assert.strictEqual(
        t.printRuntime(declaration),
        `export const Foo = t.type({
  foo: t.string
}, 'Foo')`
      )
    })

    it('should handle the isReadonly argument', () => {
      const declaration = t.typeDeclaration('Foo', t.typeCombinator([t.property('foo', t.stringType)]), true, true)
      assert.strictEqual(
        t.printRuntime(declaration),
        `export const Foo = t.readonly(t.type({
  foo: t.string
}), 'Foo')`
      )
    })

    it('should handle description argument', () => {
      const declaration = t.typeDeclaration(
        'Foo',
        t.typeCombinator([t.property('foo', t.stringType)]),
        true,
        true,
        'bar'
      )
      assert.strictEqual(
        t.printRuntime(declaration),
        `/** bar */
export const Foo = t.readonly(t.type({
  foo: t.string
}), 'Foo')`
      )
    })
  })

  it('recursiveCombinator', () => {
    const declaration = t.typeDeclaration(
      'Category',
      t.recursiveCombinator(
        t.identifier('Category'),
        'Category',
        t.typeCombinator([
          t.property('name', t.stringType),
          t.property('categories', t.arrayCombinator(t.identifier('Category')))
        ])
      )
    )
    assert.strictEqual(
      t.printStatic(declaration),
      `interface Category {
  name: string,
  categories: Array<Category>
}
interface CategoryOutput {
  name: string,
  categories: Array<CategoryOutput>
}`
    )
    assert.strictEqual(
      t.printRuntime(declaration),
      `const Category: t.Type<Category, CategoryOutput> = t.recursion('Category', () => t.type({
  name: t.string,
  categories: t.array(Category)
}))`
    )
  })

  it('readonlyArrayCombinator', () => {
    const declaration = t.typeDeclaration(
      'Foo',
      t.typeCombinator([t.property('foo', t.readonlyArrayCombinator(t.stringType))]),
      true,
      true
    )
    assert.strictEqual(
      t.printRuntime(declaration),
      `export const Foo = t.readonly(t.type({
  foo: t.readonlyArray(t.string)
}), 'Foo')`
    )
  })

  it('customCombinator', () => {
    const optionCombinator = (type: t.TypeReference): t.CustomCombinator =>
      t.customCombinator(
        `Option<${t.printStatic(type)}>`,
        `createOptionFromNullable(${t.printRuntime(type)})`,
        t.getNodeDependencies(type)
      )

    const declaration1 = t.typeDeclaration('Foo', optionCombinator(t.stringType))
    assert.strictEqual(t.printRuntime(declaration1), `const Foo = createOptionFromNullable(t.string)`)
    assert.strictEqual(t.printStatic(declaration1), `type Foo = Option<string>`)
    assert.strictEqual(t.printC(declaration1), `// exists type FooC extends t.AnyC`)
    const declaration2 = t.customCombinator(`string`, `t.string`)
    assert.strictEqual(t.printRuntime(declaration2), `t.string`)
    assert.strictEqual(t.printStatic(declaration2), `string`)
    assert.strictEqual(t.printC(declaration2), `typeof t.string`)
  })

  it('should handle custom type declaration', () => {
    const declaration = t.customTypeDeclaration(
      'Foo',
      `export type Foo = Option<string>`,
      `const Foo = createOptionFromNullable(t.string)`
    )
    assert.strictEqual(t.printRuntime(declaration), `const Foo = createOptionFromNullable(t.string)`)
    assert.strictEqual(t.printStatic(declaration), `export type Foo = Option<string>`)
    assert.strictEqual(t.printC(declaration), `// exists type FooC extends t.AnyC`)
  })

  it('StringType', () => {
    const declaration = t.typeDeclaration('Foo', t.stringType)
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.string`)
  })

  it('NumberType', () => {
    const declaration = t.typeDeclaration('Foo', t.numberType)
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.number`)
  })

  it('BooleanType', () => {
    const declaration = t.typeDeclaration('Foo', t.booleanType)
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.boolean`)
  })

  it('NullType', () => {
    const declaration = t.typeDeclaration('Foo', t.nullType)
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.null`)
  })

  it('UndefinedType', () => {
    const declaration = t.typeDeclaration('Foo', t.undefinedType)
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.undefined`)
  })

  it('IntegerType', () => {
    // tslint:disable-next-line: deprecation
    const declaration = t.typeDeclaration('Foo', t.integerType)
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.Integer`)
  })

  it('UnknownArrayType', () => {
    const declaration = t.typeDeclaration('Foo', t.unknownArrayType)
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.UnknownArray`)
  })

  it('UnknownRecordType', () => {
    const declaration = t.typeDeclaration('Foo', t.unknownRecordType)
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.UnknownRecord`)
  })

  it('FunctionType', () => {
    const declaration = t.typeDeclaration('Foo', t.functionType)
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.Function`)
  })

  it('exactCombinator', () => {
    const declaration = t.typeDeclaration(
      'Foo',
      t.exactCombinator(t.typeCombinator([t.property('foo', t.stringType), t.property('bar', t.numberType)]), 'Foo')
    )
    assert.strictEqual(
      t.printRuntime(declaration),
      `const Foo = t.exact(t.type({
  foo: t.string,
  bar: t.number
}), 'Foo')`
    )
  })

  it('UnknownType', () => {
    const declaration = t.typeDeclaration('Foo', t.unknownType)
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.unknown`)
  })

  it('intersectionCombinator', () => {
    const declaration = t.typeDeclaration(
      'Foo',
      t.intersectionCombinator([
        t.typeCombinator([t.property('a', t.stringType)]),
        t.typeCombinator([t.property('b', t.numberType)])
      ])
    )
    assert.strictEqual(
      t.printRuntime(declaration),
      `const Foo = t.intersection([
  t.type({
    a: t.string
  }),
  t.type({
    b: t.number
  })
])`
    )
  })

  it('strictCombinator', () => {
    const declaration = t.typeDeclaration(
      'Foo',
      t.strictCombinator([t.property('foo', t.stringType), t.property('bar', t.numberType)])
    )
    assert.strictEqual(
      t.printRuntime(declaration),
      `const Foo = t.strict({
  foo: t.string,
  bar: t.number
})`
    )
  })

  it('readonlyCombinator', () => {
    const D1 = t.typeDeclaration(
      'Foo',
      t.readonlyCombinator(t.typeCombinator([t.property('foo', t.stringType), t.property('bar', t.numberType)]))
    )
    assert.strictEqual(
      t.printRuntime(D1),
      `const Foo = t.readonly(t.type({
  foo: t.string,
  bar: t.number
}))`
    )
    const D2 = t.typeDeclaration(
      'Foo',
      t.readonlyCombinator(t.typeCombinator([t.property('foo', t.stringType), t.property('bar', t.numberType)]), 'Foo')
    )
    assert.strictEqual(
      t.printRuntime(D2),
      `const Foo = t.readonly(t.type({
  foo: t.string,
  bar: t.number
}), 'Foo')`
    )
  })

  it('IntType', () => {
    const declaration = t.typeDeclaration('Foo', t.intType)
    assert.strictEqual(t.printRuntime(declaration), `const Foo = t.Int`)
  })

  it('brandCombinator', () => {
    const D1 = t.typeDeclaration(
      'Foo',
      t.brandCombinator(t.numberType, (x) => `${x} >= 0`, 'Positive')
    )
    assert.strictEqual(
      t.printRuntime(D1),
      `const Foo = t.brand(t.number, (x): x is t.Branded<number, PositiveBrand> => x >= 0, 'Positive')
interface PositiveBrand {
  readonly Positive: unique symbol
}`
    )
  })
})
